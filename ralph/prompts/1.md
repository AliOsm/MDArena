# Architecture for a Git-Backed Collaborative Markdown Platform

> **Note:** Always check for the latest stable version of each package, gem, and tool before starting development. The versions listed here are current as of this writing but may have been superseded.

---

## High-Level Architecture

```
┌─────────────┐       WebSocket        ┌──────────────────┐
│   Browser    │◄──────────────────────►│  Rails App       │
│  (Inertia +  │       HTTP/REST        │  (Puma + Action  │
│   Vue 3 +    │◄──────────────────────►│   Cable via      │
│   Nuxt UI)   │                        │   Solid Cable)   │
└─────────────┘                        └────────┬─────────┘
                                                │
                    ┌───────────────┬───────────┼───────────┐
                    │               │           │           │
               ┌────▼───────┐ ┌────▼───┐ ┌────▼──────┐    │
               │ PostgreSQL  │ │ Git    │ │ GoodJob   │    │
               │ (users,     │ │ Bare   │ │ (PDF gen, │    │
               │  projects,  │ │ Repos  │ │  git ops) │    │
               │  PATs,      │ │ (disk) │ │  in-DB    │    │
               │  jobs,      │ └────────┘ └───────────┘    │
               │  cable,     │                              │
               │  cache)     │                              │
               └─────────────┘                              │
```

---

## Core Components

### 1. Authentication & Users

**Web auth**: Devise with standard cookie-based sessions.

**Git HTTP auth**: Personal Access Tokens (PATs). Users generate tokens in the web UI and use them as passwords for `git clone`, `git push`, etc.

```ruby
# app/models/personal_access_token.rb
class PersonalAccessToken < ApplicationRecord
  belongs_to :user
  has_secure_token :token

  before_create :set_digest

  scope :active, -> { where(revoked_at: nil).where("expires_at IS NULL OR expires_at > ?", Time.current) }

  def self.authenticate(plain_token)
    digest = Digest::SHA256.hexdigest(plain_token)
    active.find_by(token_digest: digest)
  end

  def revoke!
    update!(revoked_at: Time.current)
  end

  private

  def set_digest
    self.token_digest = Digest::SHA256.hexdigest(token)
    self.token_prefix = token.first(8)
  end
end
```

The plain token is shown once at creation time and never stored. Only the SHA-256 digest is persisted. Users authenticate Git operations with:

```bash
git clone https://yourapp.com/git/my-project.git
# Username: their email
# Password: pat_xxxxxxxxxxxxxxxx
```

Token management UI lets users create tokens with optional expiry dates, see active tokens (identified by prefix and name), and revoke them.

### 2. Git Repository Management

Each project maps to a **bare Git repository** on disk.

**Storage layout:**
```
/var/repos/
  ├── {project_uuid}.git/   # bare repo
  ├── {project_uuid}.git/
  └── ...
```

**Key gem**: `rugged` (Ruby bindings to libgit2). All programmatic Git operations go through Rugged — never shell out to `git`.

```ruby
# app/services/git_service.rb
class GitService
  REPOS_ROOT = Rails.configuration.repos_root

  class StaleCommitError < StandardError; end
  class FileNotFoundError < StandardError; end

  def self.repo_path(project)
    File.join(REPOS_ROOT, "#{project.uuid}.git")
  end

  def self.init_repo(project)
    path = repo_path(project)
    Rugged::Repository.init_at(path, :bare)
  end

  def self.with_repo_lock(project)
    lockfile = "#{repo_path(project)}.lock"
    File.open(lockfile, File::CREAT) do |f|
      f.flock(File::LOCK_EX)
      yield
    end
  end

  def self.read_file(project, path, ref: "HEAD")
    repo = Rugged::Repository.new(repo_path(project))
    commit = repo.rev_parse(ref)
    blob = commit.tree.path(path)
    repo.lookup(blob[:oid]).content
  rescue Rugged::TreeError
    raise FileNotFoundError, "File '#{path}' not found at ref '#{ref}'"
  end

  def self.commit_file(project:, path:, content:, user:, message:, base_sha: nil)
    with_repo_lock(project) do
      repo = Rugged::Repository.new(repo_path(project))

      if base_sha && !repo.empty? && repo.head.target_id != base_sha
        raise StaleCommitError, "Repository has changed since you started editing"
      end

      oid = repo.write(content, :blob)
      index = repo.index
      index.read_tree(repo.head.target.tree) unless repo.empty?
      index.add(path: path, oid: oid, mode: 0100644)
      tree = index.write_tree(repo)

      parents = repo.empty? ? [] : [repo.head.target]

      Rugged::Commit.create(repo, {
        tree: tree,
        author:    { name: user.name, email: user.email, time: Time.now },
        committer: { name: user.name, email: user.email, time: Time.now },
        message: message,
        parents: parents,
        update_ref: "HEAD"
      })
    end
  end

  def self.list_files(project, ref: "HEAD")
    repo = Rugged::Repository.new(repo_path(project))
    return [] if repo.empty?
    commit = repo.rev_parse(ref)
    entries = []
    commit.tree.walk_blobs { |root, entry| entries << "#{root}#{entry[:name]}" }
    entries
  end

  def self.file_history(project, path)
    repo = Rugged::Repository.new(repo_path(project))
    return [] if repo.empty?
    walker = Rugged::Walker.new(repo)
    walker.push(repo.head.target)
    walker.select { |commit|
      diff = commit.parents.any? ? commit.diff(commit.parents.first) : commit.diff
      diff.each_delta.any? { |d| d.new_file[:path] == path }
    }.map { |commit|
      { sha: commit.oid, message: commit.message, author: commit.author, time: commit.time }
    }
  end

  def self.delete_file(project:, path:, user:, message:)
    with_repo_lock(project) do
      repo = Rugged::Repository.new(repo_path(project))
      index = repo.index
      index.read_tree(repo.head.target.tree)
      index.remove(path)
      tree = index.write_tree(repo)
      Rugged::Commit.create(repo, {
        tree: tree,
        author:    { name: user.name, email: user.email, time: Time.now },
        committer: { name: user.name, email: user.email, time: Time.now },
        message: message,
        parents: [repo.head.target],
        update_ref: "HEAD"
      })
    end
  end

  def self.file_content_at(project, path, sha)
    repo = Rugged::Repository.new(repo_path(project))
    commit = repo.lookup(sha)
    blob = commit.tree.path(path)
    repo.lookup(blob[:oid]).content
  end
end
```

### 3. Git Smart HTTP via Nginx + git-http-backend

Users clone, fetch, and push over HTTPS. Nginx serves the Git Smart HTTP protocol via `git-http-backend`, with auth delegated to Rails.

**Nginx configuration:**

```nginx
upstream rails_app {
    server 127.0.0.1:3000;
}

server {
    listen 443 ssl;
    server_name yourapp.com;

    ssl_certificate     /etc/ssl/certs/yourapp.pem;
    ssl_certificate_key /etc/ssl/private/yourapp.key;

    location / {
        proxy_pass http://rails_app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /cable {
        proxy_pass http://rails_app/cable;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }

    location ~ ^/git/(?<repo_path>.+) {
        auth_request /internal/git/authorize;
        auth_request_set $auth_status $upstream_status;

        client_max_body_size 50m;

        fastcgi_pass unix:/var/run/fcgiwrap.socket;
        fastcgi_param SCRIPT_FILENAME   /usr/lib/git-core/git-http-backend;
        fastcgi_param GIT_PROJECT_ROOT  /var/repos;
        fastcgi_param GIT_HTTP_EXPORT_ALL "";
        fastcgi_param PATH_INFO         /$repo_path;
        fastcgi_param REMOTE_USER       $remote_user;

        include fastcgi_params;
    }

    location = /internal/git/authorize {
        internal;
        proxy_pass http://rails_app/api/git/authorize;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header Authorization $http_authorization;
    }
}
```

**Rails auth endpoint:**

```ruby
# app/controllers/api/git/authorize_controller.rb
class Api::Git::AuthorizeController < ApplicationController
  skip_before_action :authenticate_user!

  def show
    auth = request.headers["Authorization"]
    unless auth&.start_with?("Basic ")
      head :unauthorized and return
    end

    decoded = Base64.decode64(auth.split(" ", 2).last)
    email, token = decoded.split(":", 2)

    user = User.find_by(email: email)
    pat = PersonalAccessToken.authenticate(token)

    unless user && pat && pat.user_id == user.id
      head :unauthorized and return
    end

    pat.touch(:last_used_at)

    original_uri = request.headers["X-Original-URI"]
    slug = original_uri.match(%r{^/git/([^/]+)})&.captures&.first&.sub(/\.git$/, "")
    project = Project.find_by(slug: slug)

    unless project && project.memberships.exists?(user: user)
      head :forbidden and return
    end

    if original_uri.include?("git-receive-pack")
      membership = project.memberships.find_by(user: user)
      unless membership.role.in?(%w[owner editor])
        head :forbidden and return
      end
    end

    head :ok
  end
end
```

**Conflict handling on push**: Git handles this natively. If the remote ref has advanced since the user's last fetch, `git push` is rejected with a non-fast-forward error. The user must pull, resolve locally, and push again.

### 4. Web-Based File Editing with Commits

```ruby
# app/controllers/files_controller.rb
class FilesController < ApplicationController
  before_action :set_project

  def show
    content = GitService.read_file(@project, params[:path])
    repo = Rugged::Repository.new(GitService.repo_path(@project))
    head_sha = repo.empty? ? nil : repo.head.target_id

    render inertia: "Files/Show", props: {
      project: serialize_project(@project),
      file: { path: params[:path], content: content },
      head_sha: head_sha
    }
  end

  def edit
    content = GitService.read_file(@project, params[:path])
    repo = Rugged::Repository.new(GitService.repo_path(@project))
    head_sha = repo.empty? ? nil : repo.head.target_id

    render inertia: "Files/Edit", props: {
      project: serialize_project(@project),
      file: { path: params[:path], content: content },
      head_sha: head_sha
    }
  end

  def update
    GitService.commit_file(
      project: @project,
      path: params[:path],
      content: params[:content],
      user: current_user,
      message: params[:commit_message] || "Update #{params[:path]}",
      base_sha: params[:base_commit_sha]
    )

    redirect_to project_file_path(@project, params[:path]), notice: "File saved."
  rescue GitService::StaleCommitError
    redirect_to edit_project_file_path(@project, params[:path]),
      alert: "File changed since you started editing. Please refresh and try again."
  end

  def create
    GitService.commit_file(
      project: @project,
      path: params[:path],
      content: params[:content] || "",
      user: current_user,
      message: params[:commit_message] || "Create #{params[:path]}"
    )

    redirect_to project_file_path(@project, params[:path]), notice: "File created."
  end

  def destroy
    GitService.delete_file(
      project: @project,
      path: params[:path],
      user: current_user,
      message: "Delete #{params[:path]}"
    )

    redirect_to project_path(@project), notice: "File deleted."
  end

  def download_md
    content = GitService.read_file(@project, params[:path])
    send_data content,
      filename: File.basename(params[:path]),
      type: "text/markdown",
      disposition: "attachment"
  end

  def download_pdf
    PdfExportJob.perform_later(@project.id, params[:path], current_user.id)
    redirect_to project_file_path(@project, params[:path]),
      notice: "PDF is being generated. You'll be notified when it's ready."
  end

  private

  def set_project
    @project = current_user.projects.find_by!(slug: params[:project_slug])
  end
end
```

### 5. Real-Time Collaboration with Y.js + y-rb + Action Cable

The most complex subsystem. Y.js document state is stored in Solid Cache (PostgreSQL-backed) during active editing sessions.

**Action Cable channel:**

```ruby
# app/channels/document_channel.rb
class DocumentChannel < ApplicationCable::Channel
  def subscribed
    @project = Project.find(params[:project_id])
    @file_path = params[:file_path]
    @cache_key = "ydoc:#{@project.id}:#{@file_path}"

    reject unless current_user_can_access?(@project)

    stream_from stream_name

    state = load_or_init_ydoc
    transmit({ type: "sync", state: Base64.strict_encode64(state) })
  end

  def receive(data)
    case data["type"]
    when "update"
      update_bytes = Base64.strict_decode64(data["update"])

      doc = Y::Doc.new
      existing = Rails.cache.read(@cache_key)
      if existing
        doc.sync(existing)
      end
      doc.sync(update_bytes)

      merged_state = doc.diff
      Rails.cache.write(@cache_key, merged_state, expires_in: 2.hours)

      ActionCable.server.broadcast(stream_name, {
        type: "update",
        update: data["update"],
        sender: current_user.id
      })

      FlushYdocToGitJob.set(wait: 30.seconds).perform_later(
        @project.id, @file_path, current_user.id
      )

    when "save"
      FlushYdocToGitJob.perform_later(@project.id, @file_path, current_user.id)
    end
  end

  def unsubscribed
    FlushYdocToGitJob.set(wait: 5.seconds).perform_later(
      @project.id, @file_path, current_user.id
    )
  end

  private

  def stream_name
    "document:#{@project.id}:#{@file_path}"
  end

  def load_or_init_ydoc
    existing = Rails.cache.read(@cache_key)
    return existing if existing

    content = begin
      GitService.read_file(@project, @file_path)
    rescue GitService::FileNotFoundError
      ""
    end

    doc = Y::Doc.new
    text = doc.get_text("content")
    text.insert(0, content)
    state = doc.diff
    Rails.cache.write(@cache_key, state, expires_in: 2.hours)
    state
  end

  def current_user_can_access?(project)
    project.memberships.exists?(user: current_user)
  end
end
```

**GoodJob flush job:**

```ruby
# app/jobs/flush_ydoc_to_git_job.rb
class FlushYdocToGitJob < ApplicationJob
  queue_as :default

  good_job_control_concurrency_with(
    key: -> { "flush_ydoc:#{arguments[0]}:#{arguments[1]}" },
    total_limit: 1
  )

  def perform(project_id, file_path, user_id)
    project = Project.find(project_id)
    user = User.find(user_id)
    cache_key = "ydoc:#{project.id}:#{file_path}"

    state = Rails.cache.read(cache_key)
    return unless state

    doc = Y::Doc.new
    doc.sync(state)
    text = doc.get_text("content")
    content = text.to_s

    begin
      existing = GitService.read_file(project, file_path)
      return if existing == content
    rescue GitService::FileNotFoundError
      # File doesn't exist yet, proceed
    end

    GitService.commit_file(
      project: project,
      path: file_path,
      content: content,
      user: user,
      message: "Auto-save #{file_path}"
    )
  end
end
```

**Frontend (Vue 3 + Nuxt UI component with Y.js):**

```vue
<!-- app/javascript/pages/Files/Edit.vue -->
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import { EditorView, basicSetup } from 'codemirror'
import { markdown } from '@codemirror/lang-markdown'
import * as Y from 'yjs'
import { yCollab } from 'y-codemirror.next'
import consumer from '../../channels/consumer'

const props = defineProps({
  project: Object,
  file: Object,
  headSha: String,
})

const editorContainer = ref(null)
const status = ref('connecting')
const toast = useToast()

let ydoc = null
let channel = null
let view = null

onMounted(() => {
  ydoc = new Y.Doc()
  const ytext = ydoc.getText('content')
  const undoManager = new Y.UndoManager(ytext)

  channel = consumer.subscriptions.create(
    {
      channel: 'DocumentChannel',
      project_id: props.project.id,
      file_path: props.file.path,
    },
    {
      received(data) {
        if (data.type === 'sync') {
          const state = Uint8Array.from(atob(data.state), (c) => c.charCodeAt(0))
          Y.applyUpdate(ydoc, state)
          status.value = 'connected'
        } else if (data.type === 'update' && data.sender !== window.currentUserId) {
          const update = Uint8Array.from(atob(data.update), (c) => c.charCodeAt(0))
          Y.applyUpdate(ydoc, update)
        }
      },
      connected() {
        status.value = 'connected'
      },
      disconnected() {
        status.value = 'disconnected'
      },
    },
  )

  ydoc.on('update', (update, origin) => {
    if (origin !== 'remote') {
      const encoded = btoa(String.fromCharCode(...update))
      channel.send({ type: 'update', update: encoded })
    }
  })

  view = new EditorView({
    parent: editorContainer.value,
    extensions: [basicSetup, markdown(), yCollab(ytext, null, { undoManager })],
  })
})

onUnmounted(() => {
  channel?.unsubscribe()
  view?.destroy()
  ydoc?.destroy()
})

function save() {
  channel.send({ type: 'save' })
  toast.add({ title: 'Saving...', icon: 'i-heroicons-arrow-path', color: 'info' })
}
</script>

<template>
  <div>
    <div class="flex items-center justify-between mb-4">
      <UBadge :color="status === 'connected' ? 'success' : 'error'" variant="subtle">
        {{ status }}
      </UBadge>
      <UButton icon="i-heroicons-arrow-down-tray" label="Save" @click="save" />
    </div>
    <div ref="editorContainer" class="border rounded-lg" />
  </div>
</template>
```

### 6. File History

```ruby
# app/controllers/file_history_controller.rb
class FileHistoryController < ApplicationController
  before_action :set_project

  def index
    history = GitService.file_history(@project, params[:path])
    render inertia: "Files/History", props: {
      project: serialize_project(@project),
      path: params[:path],
      history: history
    }
  end

  def show
    content = GitService.file_content_at(@project, params[:path], params[:sha])
    render inertia: "Files/HistoryShow", props: {
      project: serialize_project(@project),
      path: params[:path],
      sha: params[:sha],
      content: content
    }
  end

  private

  def set_project
    @project = current_user.projects.find_by!(slug: params[:project_slug])
  end
end
```

```vue
<!-- app/javascript/pages/Files/History.vue -->
<script setup>
import { Link } from '@inertiajs/vue3'

const props = defineProps({
  project: Object,
  path: String,
  history: Array,
})

const columns = [
  { key: 'sha', label: 'Commit' },
  { key: 'message', label: 'Message' },
  { key: 'author', label: 'Author' },
  { key: 'time', label: 'Date' },
  { key: 'actions', label: '' },
]

const rows = props.history.map((entry) => ({
  sha: entry.sha.slice(0, 8),
  fullSha: entry.sha,
  message: entry.message,
  author: entry.author.name,
  time: new Date(entry.time).toLocaleString(),
}))
</script>

<template>
  <div>
    <div class="flex items-center justify-between mb-6">
      <h2 class="text-xl font-semibold">History: {{ path }}</h2>
      <UButton
        :href="`/projects/${project.slug}/files/${path}`"
        :is="Link"
        variant="ghost"
        icon="i-heroicons-arrow-left"
        label="Back to file"
      />
    </div>

    <UTable :columns="columns" :rows="rows">
      <template #sha-data="{ row }">
        <UBadge variant="subtle" color="neutral">
          <code>{{ row.sha }}</code>
        </UBadge>
      </template>
      <template #actions-data="{ row }">
        <UButton
          :href="`/projects/${project.slug}/files/${path}/history/${row.fullSha}`"
          :is="Link"
          size="xs"
          variant="ghost"
          icon="i-heroicons-eye"
          label="View"
        />
      </template>
    </UTable>

    <UAlert
      v-if="history.length === 0"
      title="No history"
      description="This file has no recorded changes yet."
      icon="i-heroicons-information-circle"
      color="info"
    />
  </div>
</template>
```

### 7. Markdown Preview & PDF Export

**Preview**: Client-side with `markdown-it` in a split pane or toggle view.

```vue
<!-- app/javascript/components/MarkdownPreview.vue -->
<script setup>
import { computed } from 'vue'
import MarkdownIt from 'markdown-it'

const props = defineProps({ content: String })
const md = new MarkdownIt({ html: false, linkify: true, typographer: true })
const rendered = computed(() => md.render(props.content || ''))
</script>

<template>
  <div class="prose prose-sm max-w-none dark:prose-invert" v-html="rendered" />
</template>
```

**PDF export with Grover:**

```ruby
# config/initializers/grover.rb
Grover.configure do |config|
  config.options = {
    format: 'A4',
    margin: { top: '1cm', bottom: '1cm', left: '1.5cm', right: '1.5cm' },
    print_background: true
  }

  if Rails.env.development?
    config.options[:launch_args] = ['--no-sandbox']
    config.options[:browser_ws_endpoint] = 'ws://localhost:3333'
  end
end

# app/jobs/pdf_export_job.rb
class PdfExportJob < ApplicationJob
  queue_as :pdf_export

  def perform(project_id, file_path, user_id)
    project = Project.find(project_id)
    content = GitService.read_file(project, file_path)

    html = <<~HTML
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                 line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto;
                 padding: 2em; }
          h1 { border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
          h2 { border-bottom: 1px solid #f0f0f0; padding-bottom: 0.2em; }
          code { background: #f6f8fa; padding: 0.2em 0.4em; border-radius: 3px;
                 font-size: 0.9em; }
          pre code { display: block; padding: 1em; overflow-x: auto; }
          blockquote { border-left: 4px solid #dfe2e5; margin: 0; padding-left: 1em;
                       color: #6a737d; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #dfe2e5; padding: 6px 13px; }
          img { max-width: 100%; }
        </style>
      </head>
      <body>#{CommonMarker.render_html(content, :DEFAULT, [:table, :strikethrough, :tasklist])}</body>
      </html>
    HTML

    pdf = Grover.new(html).to_pdf

    blob = ActiveStorage::Blob.create_and_upload!(
      io: StringIO.new(pdf),
      filename: "#{File.basename(file_path, '.md')}.pdf",
      content_type: 'application/pdf'
    )

    ActionCable.server.broadcast(
      "user:#{user_id}:notifications",
      {
        type: "pdf_ready",
        filename: blob.filename.to_s,
        url: Rails.application.routes.url_helpers.rails_blob_path(blob, disposition: "attachment")
      }
    )
  end
end
```

### 8. Frontend with Inertia.js + Vue 3 + Nuxt UI

Nuxt UI 3 is built on Reka UI and Tailwind CSS 4. The `@nuxt/ui-vue` package provides the component library for standalone Vue + Vite apps without requiring the full Nuxt framework.

```ruby
# Gemfile
gem 'inertia_rails'
gem 'vite_rails'
```

```json
// package.json
{
  "packageManager": "yarn@4.12.0",
  "dependencies": {
    "@inertiajs/vue3": "^2.0",
    "@nuxt/ui-vue": "^3.0",
    "@iconify-json/heroicons": "^1.2",
    "@iconify-json/lucide": "^1.2",
    "vue": "^3.5",
    "codemirror": "^6",
    "@codemirror/lang-markdown": "^6",
    "y-codemirror.next": "^0.3",
    "yjs": "^13",
    "markdown-it": "^14",
    "@vitejs/plugin-vue": "^5",
    "vite": "^6",
    "vite-plugin-ruby": "^5",
    "tailwindcss": "^4",
    "@actioncable/core": "^8"
  },
  "devDependencies": {
    "oxlint": "^0.16",
    "oxfmt": "^0.1"
  },
  "scripts": {
    "lint": "oxlint ./app/javascript",
    "format": "oxfmt --write 'app/javascript/**/*.{vue,js,ts}'",
    "format:check": "oxfmt --check 'app/javascript/**/*.{vue,js,ts}'"
  }
}
```

**Vite config with Nuxt UI:**

```js
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import ViteRuby from 'vite-plugin-ruby'
import ui from '@nuxt/ui-vue/vite'

export default defineConfig({
  plugins: [
    vue(),
    ViteRuby(),
    ui({
      ui: {
        colors: {
          primary: 'blue',
          neutral: 'slate',
        },
      },
      colorMode: true,
    }),
  ],
  resolve: {
    alias: {
      '@': '/app/javascript',
    },
  },
})
```

**Tailwind CSS 4 config:**

```css
/* app/javascript/css/application.css */
@import "tailwindcss";
@import "@nuxt/ui-vue/theme.css";

@source "../**/*.{vue,js,ts}";
```

Tailwind CSS 4 uses the CSS-first configuration approach — no `tailwind.config.js` needed. The `@source` directive tells Tailwind where to scan for class usage.

**oxfmt configuration with Tailwind CSS class sorting:**

```json
// .oxfmt.json
{
  "printWidth": 100,
  "semi": false,
  "singleQuote": true,
  "trailingComma": "all",
  "plugins": {
    "tailwindcss": {
      "enabled": true,
      "classAttributes": ["class", "className"],
      "functions": ["cn", "clsx", "tw"]
    }
  }
}
```

The Tailwind plugin automatically sorts utility classes in `class` attributes within Vue templates, following the official recommended order.

**Inertia app entry with Nuxt UI plugin:**

```js
// app/javascript/entrypoints/application.js
import { createApp, h } from 'vue'
import { createInertiaApp } from '@inertiajs/vue3'
import nuxtUI from '@nuxt/ui-vue/plugin'
import AppLayout from '@/layouts/AppLayout.vue'
import '../css/application.css'

createInertiaApp({
  resolve: (name) => {
    const pages = import.meta.glob('../pages/**/*.vue', { eager: true })
    const page = pages[`../pages/${name}.vue`]
    page.default.layout = page.default.layout || AppLayout
    return page
  },
  setup({ el, App, props, plugin }) {
    createApp({ render: () => h(App, props) })
      .use(plugin)
      .use(nuxtUI)
      .mount(el)
  },
})
```

**App layout:**

```vue
<!-- app/javascript/layouts/AppLayout.vue -->
<script setup>
import { Link, usePage } from '@inertiajs/vue3'

const { auth } = usePage().props
</script>

<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-950">
    <header class="border-b border-gray-200 bg-white dark:border-gray-800 dark:bg-gray-900">
      <UContainer>
        <div class="flex h-14 items-center justify-between">
          <Link href="/projects" class="text-lg font-semibold">
            MarkdownForge
          </Link>
          <div class="flex items-center gap-2">
            <span class="text-sm text-gray-500">{{ auth.user.name }}</span>
            <UButton
              :is="Link"
              href="/settings/tokens"
              variant="ghost"
              size="sm"
              icon="i-heroicons-key"
              label="Tokens"
            />
            <UButton
              :is="Link"
              href="/settings"
              variant="ghost"
              size="sm"
              icon="i-heroicons-cog-6-tooth"
              label="Settings"
            />
            <UButton
              :is="Link"
              href="/logout"
              method="delete"
              variant="ghost"
              size="sm"
              color="error"
              icon="i-heroicons-arrow-right-on-rectangle"
              label="Log out"
            />
          </div>
        </div>
      </UContainer>
    </header>

    <main>
      <UContainer class="py-8">
        <slot />
      </UContainer>
    </main>

    <UNotifications />
  </div>
</template>
```

**Example pages using Nuxt UI:**

```vue
<!-- app/javascript/pages/Projects/Index.vue -->
<script setup>
import { Link, router } from '@inertiajs/vue3'
import { ref } from 'vue'

defineProps({ projects: Array })

const isCreateOpen = ref(false)
const newProjectName = ref('')

function createProject() {
  router.post('/projects', { name: newProjectName.value }, {
    onSuccess: () => {
      isCreateOpen.value = false
      newProjectName.value = ''
    },
  })
}
</script>

<template>
  <div>
    <div class="mb-6 flex items-center justify-between">
      <h1 class="text-2xl font-bold">Projects</h1>
      <UButton icon="i-heroicons-plus" label="New Project" @click="isCreateOpen = true" />
    </div>

    <UModal v-model:open="isCreateOpen">
      <template #header>
        <h3 class="text-lg font-semibold">Create New Project</h3>
      </template>
      <template #body>
        <UFormField label="Project Name">
          <UInput
            v-model="newProjectName"
            placeholder="My awesome docs"
            autofocus
            @keyup.enter="createProject"
          />
        </UFormField>
      </template>
      <template #footer>
        <div class="flex justify-end gap-2">
          <UButton variant="ghost" label="Cancel" @click="isCreateOpen = false" />
          <UButton label="Create" @click="createProject" />
        </div>
      </template>
    </UModal>

    <div class="grid gap-4">
      <UCard
        v-for="project in projects"
        :key="project.id"
        :is="Link"
        :href="`/projects/${project.slug}`"
        class="transition hover:ring-2 hover:ring-primary-500"
      >
        <div class="flex items-center justify-between">
          <div>
            <h3 class="font-semibold">{{ project.name }}</h3>
            <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
              owned by {{ project.owner }} · updated {{ project.updated_at }}
            </p>
          </div>
          <UBadge variant="subtle">{{ project.role }}</UBadge>
        </div>
      </UCard>
    </div>

    <UAlert
      v-if="projects.length === 0"
      title="No projects yet"
      description="Create your first project to get started."
      icon="i-heroicons-folder-plus"
      color="info"
      class="mt-4"
    />
  </div>
</template>
```

```vue
<!-- app/javascript/pages/Projects/Show.vue -->
<script setup>
import { Link, router } from '@inertiajs/vue3'
import { ref } from 'vue'

const props = defineProps({
  project: Object,
  files: Array,
})

const isCreateFileOpen = ref(false)
const newFileName = ref('')

function createFile() {
  const path = newFileName.value.endsWith('.md') ? newFileName.value : `${newFileName.value}.md`
  router.post(`/projects/${props.project.slug}/files`, { path, content: `# ${newFileName.value.replace('.md', '')}\n` }, {
    onSuccess: () => {
      isCreateFileOpen.value = false
      newFileName.value = ''
    },
  })
}
</script>

<template>
  <div>
    <div class="mb-6 flex items-center justify-between">
      <div>
        <h1 class="text-2xl font-bold">{{ project.name }}</h1>
        <div class="mt-1 flex items-center gap-2">
          <UBadge variant="subtle">{{ project.role }}</UBadge>
          <code class="rounded bg-gray-100 px-2 py-0.5 text-xs text-gray-500 dark:bg-gray-800">
            {{ project.clone_url }}
          </code>
        </div>
      </div>
      <UButton icon="i-heroicons-document-plus" label="New File" @click="isCreateFileOpen = true" />
    </div>

    <UModal v-model:open="isCreateFileOpen">
      <template #header>
        <h3 class="text-lg font-semibold">Create New File</h3>
      </template>
      <template #body>
        <UFormField label="File Name">
          <UInput
            v-model="newFileName"
            placeholder="my-document.md"
            autofocus
            @keyup.enter="createFile"
          />
        </UFormField>
      </template>
      <template #footer>
        <div class="flex justify-end gap-2">
          <UButton variant="ghost" label="Cancel" @click="isCreateFileOpen = false" />
          <UButton label="Create" @click="createFile" />
        </div>
      </template>
    </UModal>

    <div class="space-y-1">
      <UButton
        v-for="file in files"
        :key="file"
        :is="Link"
        :href="`/projects/${project.slug}/files/${file}`"
        variant="ghost"
        block
        class="justify-start"
        icon="i-heroicons-document-text"
        :label="file"
      />
    </div>

    <UAlert
      v-if="files.length === 0"
      title="No files yet"
      description="Create your first markdown file or push files via Git."
      icon="i-heroicons-document-plus"
      color="info"
      class="mt-4"
    />
  </div>
</template>
```

**Token management page:**

```vue
<!-- app/javascript/pages/Settings/Tokens.vue -->
<script setup>
import { router } from '@inertiajs/vue3'
import { ref } from 'vue'

const props = defineProps({
  tokens: Array,
  newToken: { type: String, default: null },
})

const toast = useToast()
const isCreateOpen = ref(false)
const tokenName = ref('')

function createToken() {
  router.post('/settings/tokens', { name: tokenName.value }, {
    onSuccess: () => {
      isCreateOpen.value = false
      tokenName.value = ''
    },
  })
}

function revokeToken(id) {
  router.delete(`/settings/tokens/${id}`)
  toast.add({ title: 'Token revoked', icon: 'i-heroicons-check-circle', color: 'success' })
}
</script>

<template>
  <div>
    <div class="mb-6 flex items-center justify-between">
      <h1 class="text-2xl font-bold">Personal Access Tokens</h1>
      <UButton icon="i-heroicons-plus" label="New Token" @click="isCreateOpen = true" />
    </div>

    <UAlert
      v-if="newToken"
      title="Token created — copy it now, it won't be shown again"
      :description="newToken"
      icon="i-heroicons-exclamation-triangle"
      color="warning"
      class="mb-6 font-mono"
    />

    <UModal v-model:open="isCreateOpen">
      <template #header>
        <h3 class="text-lg font-semibold">Create Token</h3>
      </template>
      <template #body>
        <UFormField label="Token Name" hint="e.g. 'My laptop', 'CI server'">
          <UInput
            v-model="tokenName"
            placeholder="My laptop"
            autofocus
            @keyup.enter="createToken"
          />
        </UFormField>
      </template>
      <template #footer>
        <div class="flex justify-end gap-2">
          <UButton variant="ghost" label="Cancel" @click="isCreateOpen = false" />
          <UButton label="Create" @click="createToken" />
        </div>
      </template>
    </UModal>

    <UTable
      :columns="[
        { key: 'name', label: 'Name' },
        { key: 'prefix', label: 'Token' },
        { key: 'lastUsed', label: 'Last Used' },
        { key: 'actions', label: '' },
      ]"
      :rows="tokens.map((t) => ({
        id: t.id,
        name: t.name,
        prefix: t.token_prefix + '••••••••',
        lastUsed: t.last_used_at ? new Date(t.last_used_at).toLocaleString() : 'Never',
      }))"
    >
      <template #prefix-data="{ row }">
        <code class="text-sm">{{ row.prefix }}</code>
      </template>
      <template #actions-data="{ row }">
        <UButton
          size="xs"
          color="error"
          variant="ghost"
          icon="i-heroicons-trash"
          label="Revoke"
          @click="revokeToken(row.id)"
        />
      </template>
    </UTable>
  </div>
</template>
```

**Example controller pattern:**

```ruby
# app/controllers/projects_controller.rb
class ProjectsController < ApplicationController
  def index
    projects = current_user.projects.includes(:owner).order(updated_at: :desc)
    render inertia: 'Projects/Index', props: {
      projects: projects.map { |p| serialize_project(p) }
    }
  end

  def show
    project = current_user.projects.find_by!(slug: params[:slug])
    files = GitService.list_files(project)
    render inertia: 'Projects/Show', props: {
      project: serialize_project(project),
      files: files
    }
  end

  def create
    project = current_user.owned_projects.build(project_params)
    project.slug = project.name.parameterize

    if project.save
      GitService.init_repo(project)
      project.memberships.create!(user: current_user, role: 'owner')
      redirect_to project_path(project), notice: "Project created."
    else
      redirect_back fallback_location: projects_path, alert: project.errors.full_messages.join(", ")
    end
  end

  private

  def project_params
    params.require(:project).permit(:name)
  end

  def serialize_project(project)
    {
      id: project.id,
      name: project.name,
      slug: project.slug,
      uuid: project.uuid,
      role: project.memberships.find_by(user: current_user)&.role,
      owner: project.owner.name,
      updated_at: project.updated_at.iso8601,
      clone_url: "#{request.base_url}/git/#{project.slug}.git"
    }
  end
end
```

### 9. Background Jobs with GoodJob

```ruby
# Gemfile
gem 'good_job'

# config/application.rb
config.active_job.queue_adapter = :good_job

# config/initializers/good_job.rb
Rails.application.configure do
  config.good_job = {
    execution_mode: :async,
    queues: 'default:5;pdf_export:2',
    max_threads: 7,
    poll_interval: 5,
    shutdown_timeout: 25,
    enable_cron: true,
    cron: {
      cleanup_expired_tokens: {
        cron: '0 3 * * *',
        class: 'CleanupExpiredTokensJob'
      },
      cleanup_stale_ydocs: {
        cron: '*/15 * * * *',
        class: 'CleanupStaleYdocsJob'
      }
    },
    dashboard_default_locale: :en
  }
end

# config/routes.rb
authenticate :user, ->(user) { user.admin? } do
  mount GoodJob::Engine => '/good_job'
end
```

---

## Data Model

```ruby
create_table :users do |t|
  t.string :name, null: false
  t.string :email, null: false
  t.string :encrypted_password, null: false
  t.boolean :admin, default: false
  t.timestamps
  t.index :email, unique: true
end

create_table :personal_access_tokens do |t|
  t.references :user, null: false, foreign_key: true
  t.string :name, null: false
  t.string :token_digest, null: false
  t.string :token_prefix, limit: 8
  t.datetime :last_used_at
  t.datetime :expires_at
  t.datetime :revoked_at
  t.timestamps
  t.index :token_digest, unique: true
end

create_table :projects do |t|
  t.string :name, null: false
  t.string :slug, null: false
  t.uuid :uuid, null: false, default: "gen_random_uuid()"
  t.references :owner, null: false, foreign_key: { to_table: :users }
  t.timestamps
  t.index :slug, unique: true
  t.index :uuid, unique: true
end

create_table :project_memberships do |t|
  t.references :user, null: false, foreign_key: true
  t.references :project, null: false, foreign_key: true
  t.string :role, null: false, default: 'editor'
  t.timestamps
  t.index [:user_id, :project_id], unique: true
end

# Optional: cache file metadata for faster listing
create_table :documents do |t|
  t.references :project, null: false, foreign_key: true
  t.string :path, null: false
  t.string :last_commit_sha
  t.datetime :last_modified_at
  t.timestamps
  t.index [:project_id, :path], unique: true
end
```

---

## Development Environment

### mise Configuration

mise manages Ruby, Node, and Yarn versions and provides a task runner that orchestrates the entire development workflow.

```toml
# .mise.toml
[tools]
node = "25.2.1"
ruby = "3.4.7"
yarn = "4.12.0"

[tasks."docker:start"]
description = "Start Docker services using docker-compose"
run = "docker compose -f dev-docker-compose.yml up -d"

[tasks."docker:stop"]
description = "Stop Docker services using docker-compose"
run = "docker compose -f dev-docker-compose.yml down"

[tasks."deps"]
description = "Install dependencies"
run = "mise run deps:ruby && mise run deps:js"

[tasks."deps:ruby"]
description = "Install Ruby gems"
run = "bundle install"

[tasks."deps:js"]
description = "Install JavaScript dependencies"
run = "yarn install"

[tasks."db:prepare"]
description = "Prepare database"
run = "bundle exec rails db:prepare"

[tasks.lint]
description = "Run Ruby and JavaScript lint using Rubocop and Oxlint"
run = '''
set +e

bundle exec rubocop || echo "❌ Ruby lint failed"
yarn format:check || echo "❌ JavaScript format check failed"
yarn lint || echo "❌ JavaScript lint failed"
'''

[tasks.test]
description = "Run unit tests"
run = "CI=1 bundle exec rails test"

[tasks.dev]
description = "Start development environment"
run = '''
mise run docker:start
mise run deps
mise run db:prepare

cleanup() {
  mise docker:stop

  exit 0
}

# Set up trap to call cleanup on SIGINT (Ctrl+C) and SIGTERM
trap cleanup SIGINT SIGTERM

./bin/dev

cleanup
'''
```

**Key design decisions:**

- **`mise run dev` is the single entry point.** It starts Docker services, installs all dependencies, prepares the database, runs Foreman-managed processes, and tears down Docker on exit. A new developer clones the repo and runs `mise run dev` — that's it.
- **Graceful shutdown.** The `trap` on SIGINT/SIGTERM ensures `docker compose down` runs when the developer hits Ctrl+C.
- **`mise run lint` runs all linters in one pass.** Rubocop for Ruby, Oxlint for JS correctness, oxfmt for JS/Vue formatting. `set +e` ensures all linters run even if one fails.
- **Dependency tasks are composable.** `mise run deps` calls both sub-tasks. You can also run them individually.

### Docker Compose for Development Services

Only PostgreSQL and Chromium (for Grover PDF generation) run in Docker. Rails, Vite, and GoodJob run natively via mise.

```yaml
# dev-docker-compose.yml
services:
  postgres:
    image: postgres:18-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 3s
      retries: 5

  chromium:
    image: browserless/chrome:latest
    ports:
      - "3333:3000"
    environment:
      CONNECTION_TIMEOUT: 60000

volumes:
  pgdata:
```

### Linting & Formatting

**Ruby — Rubocop:**

```yaml
# .rubocop.yml
require:
  - rubocop-rails
  - rubocop-minitest
  - rubocop-performance

AllCops:
  TargetRubyVersion: 3.4
  NewCops: enable
  Exclude:
    - 'db/schema.rb'
    - 'bin/**/*'
    - 'node_modules/**/*'
    - 'vendor/**/*'

Style/Documentation:
  Enabled: false

Metrics/MethodLength:
  Max: 20

Layout/LineLength:
  Max: 120
```

**JavaScript/Vue — Oxlint + oxfmt:**

```json
// .oxlintrc.json
{
  "rules": {
    "no-unused-vars": "warn",
    "no-console": "warn",
    "eqeqeq": "error"
  },
  "ignorePatterns": ["node_modules", "public", "tmp"]
}
```

### Foreman Procfile

```
# Procfile.dev (run by bin/dev via Foreman)
web: bin/rails server -p 3000
js: yarn vite dev
jobs: bundle exec good_job start
```

### Developer Onboarding

```bash
# 1. Install mise (one-time)
curl https://mise.run | sh

# 2. Clone and run
git clone https://github.com/yourorg/mdforge.git
cd mdforge
mise install    # installs Ruby 3.4.7, Node 25.2.1, Yarn 4.12.0
mise run dev    # starts everything: Docker → deps → db:prepare → bin/dev
```

On Ctrl+C, Docker services are stopped automatically.

---

## Deployment with Kamal

```yaml
# config/deploy.yml
service: mdforge

image: yourregistry/mdforge

servers:
  web:
    hosts:
      - 123.45.67.89
    options:
      memory: 2g
    volumes:
      - /var/repos:/var/repos

  jobs:
    hosts:
      - 123.45.67.89
    cmd: bundle exec good_job start
    options:
      memory: 1g
    volumes:
      - /var/repos:/var/repos

proxy:
  ssl: true
  host: yourapp.com
  app_port: 3000

registry:
  server: ghcr.io
  username: your-github-user
  password:
    - KAMAL_REGISTRY_PASSWORD

builder:
  arch: amd64

env:
  clear:
    RAILS_ENV: production
    RAILS_LOG_TO_STDOUT: "1"
    GOOD_JOB_EXECUTION_MODE: external
    GIT_REPOS_ROOT: /var/repos
  secret:
    - RAILS_MASTER_KEY
    - DATABASE_URL
    - CABLE_DATABASE_URL
    - CACHE_DATABASE_URL
    - QUEUE_DATABASE_URL

accessories:
  postgres:
    image: postgres:18-alpine
    host: 123.45.67.89
    port: "127.0.0.1:5432:5432"
    env:
      secret:
        - POSTGRES_PASSWORD
    directories:
      - pgdata:/var/lib/postgresql/data

  nginx:
    image: nginx:alpine
    host: 123.45.67.89
    port: "443:443"
    files:
      - config/nginx/app.conf:/etc/nginx/conf.d/default.conf
    directories:
      - /var/repos:/var/repos:ro
      - /etc/ssl:/etc/ssl:ro
```

---

## Tech Stack Summary

| Layer | Choice |
|---|---|
| **Framework** | Ruby on Rails 8.1.2 |
| **Ruby** | 3.4.7 (via mise) |
| **Node** | 25.2.1 (via mise) |
| **Package manager** | Yarn 4.12.0 (via mise) |
| **Database** | PostgreSQL 18 |
| **Cache** | Solid Cache |
| **WebSocket pub/sub** | Solid Cable |
| **Background jobs** | GoodJob |
| **Git operations** | Rugged (libgit2) |
| **Git HTTP serving** | Nginx + git-http-backend + fcgiwrap |
| **Git auth** | Personal Access Tokens (PATs) via Basic Auth |
| **Realtime collab** | Y.js (frontend) + y-rb (backend) + Action Cable |
| **Editor** | CodeMirror 6 + y-codemirror.next |
| **Frontend** | Inertia.js + Vue 3 + Vite |
| **UI components** | Nuxt UI 3 (via `@nuxt/ui-vue`) |
| **CSS** | Tailwind CSS 4 |
| **MD rendering** | markdown-it (client), commonmarker (server) |
| **PDF generation** | Grover (Puppeteer/Chromium) |
| **Web server** | Puma behind Nginx |
| **Auth** | Devise (web), PATs (Git) |
| **Ruby linting** | Rubocop |
| **JS linting & formatting** | Oxlint + oxfmt (with Tailwind class sorting) |
| **Dev environment** | mise + Docker Compose |
| **Deployment** | Kamal 2 |
| **Server OS** | Ubuntu 24.04 |

---

## Infrastructure for 100–500 Users

A **single server** handles this scale comfortably.

**Recommended server:** 4 vCPUs, 8 GB RAM, 200 GB SSD (Hetzner CPX31 ~€15/mo, or DigitalOcean 8GB ~$48/mo).

**Process allocation:**

| Process | Resources |
|---|---|
| Puma (2 workers × 5 threads) | ~400 MB RAM |
| GoodJob (separate process, 7 threads) | ~200 MB RAM |
| PostgreSQL | ~1 GB RAM |
| Chromium (ephemeral, for PDF) | ~200 MB per render |
| Nginx + fcgiwrap | ~50 MB RAM |
| Git repos (markdown only) | negligible disk |

**Backups:** Daily `pg_dump` + rsync of `/var/repos` to offsite storage (S3, Backblaze B2, or a second VPS). Automate with a GoodJob cron entry.

---

## Estimated Development Effort

| Component | Effort |
|---|---|
| Dev environment (mise, Docker Compose, Vite, Inertia + Vue + Nuxt UI, linting) | 1 week |
| Auth (Devise + PAT model + token management UI) | 1–2 weeks |
| Project CRUD + memberships + invite flow | 1–2 weeks |
| Git repo management via Rugged | 2–3 weeks |
| Nginx + git-http-backend + PAT auth | 1–2 weeks |
| Markdown editor (CodeMirror 6 + Vue) + preview | 1–2 weeks |
| Real-time collaboration (Y.js + y-rb + Action Cable) | 3–4 weeks |
| File history UI + version viewing | 1 week |
| PDF export with Grover + MD download | 1 week |
| Vue pages with Nuxt UI, UI/UX polish, permissions, error handling | 2–3 weeks |
| Kamal deployment + production hardening | 1 week |
| Testing (Minitest + system tests with Capybara) | 2 weeks |
| **Total** | **~17–24 weeks** for a solo experienced Rails dev |

Nuxt UI reduces UI effort — modals, tables, badges, alerts, toasts, forms, and buttons come out of the box with consistent styling and dark mode support.

---

## Key Risks and Mitigations

**Nuxt UI outside of Nuxt**: The `@nuxt/ui-vue` package works for standalone Vue + Vite apps, but some features that rely on Nuxt internals (like `useColorMode` auto-injection) may need manual wiring. Start with the core components (UButton, UCard, UTable, UModal, UInput, UAlert, UBadge, UNotifications) which work reliably, and avoid Nuxt-specific patterns.

**Real-time collaboration complexity**: The `y-rb` gem is functional but less battle-tested than the JS Y.js ecosystem. Mitigation: ship single-user editing first (lock file while someone is editing), then layer in CRDT collaboration as phase 2. This cuts 3–4 weeks from the initial build.

**Git repo corruption from concurrent writes**: All Rugged write operations are wrapped in `with_repo_lock` using `File.flock`. If you ever move to multiple app servers, switch to a PostgreSQL advisory lock.

**Y.js ↔ Git state drift**: The Y.js document is the "live" state while editors are active; Git is the "persisted" state. When all editors disconnect, the Y.js state is flushed to Git and the cache entry expires. Make this contract clear in the UI with a "saved" / "unsaved changes" indicator.

**Grover/Chromium memory**: Limit PDF concurrency to 2 via GoodJob's `good_job_control_concurrency_with`, and set a timeout on Grover renders.

**PAT security**: Rate-limit the Git auth endpoint (Rack::Attack), log usage with IP and timestamp, auto-expire unused tokens after 90 days via the cron job.
